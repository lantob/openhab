// In openhab 3.0 wird org.eclipse nicht mehr genutzt, statt dessen org.openhab.core verwenden0
//import org.eclipse.smartwup.model.script.ScriptServiceUtil
import org.openhab.core.model.script.ScriptServiceUtil
// import org.joda.time.*
// import java.util.Calendar
// import java.util.Date
// import java.text.SimpleDateFormat

// Der .json String muss aktuell in der Datei selbst definiert sein, hier werden aber Color und Brightness je nach Wert Szene
val String json = '{"lr":
    {"0": {"mood": "OFF", "brightness": "0", "color": "40"},
    "1": {"mood": "ON", "brightness": "100", "color": "0"},
    "2": {"mood": "night", "brightness": "50", "color": "100"},
    "3": {"mood": "morning", "brightness": "100", "color": "50"},
    "4": {"mood": "work", "brightness": "100", "color": "0"},
    "5": {"mood": "dinner", "brightness": "70", "color": "80"},
    "6": {"mood": "tv", "brightness": "50", "color": "60"},
    "7": {"mood": "cooking", "brightness":"100", "color":"0"},
    "8": {"mood": "morning", "brightness": "100", "color": "50"}}
}'


rule "Lichter updaten"
when
    Member of group_scenes changed 
then
     // LEGACY FUNKTION VON littlechina
     /* 
	Bei Statuswechsel eines Items der Gruppe group_scenes wird zunächst eine neue Gruppe definiert, die alle Lichter enthäudot, die im selben Raum in der gewählten Szene sind. Dafür muss das triggerende Item zwingend mit Schema RAUMNAME_ beginnen. Der String wird aufgeteilt der Raumname so wieder in den Funktionen recycelt. Für Tradfri Lampen wird eine zweite Gruppe für die Colorn mitgesetzt, damit diese auch bei Szenenwechsel entsprechend angepasst werden.
	Damit der Folgende Code funktioniert, müssen auch die Lichtgruppen strikt nach Schema group_RAUMNAME_LIGHTS_SZENE benannt sein. Für Farbwechsellampen wird bei Tradfri eine weitere Gruppe mit den Colorn benötigt. (Tradfri steuert die Farbe über einen seperaten Channel. )0
    */

    val roomName = triggeringItem.name.split("_").get(0) 
    val group = ScriptServiceUtil.getItemRegistry.getItem("group_"+roomName +"_lights") as GroupItem
    val groupCol = ScriptServiceUtil.getItemRegistry.getItem("group_"+roomName +"_color") as GroupItem
    val strColor = transform("JSONPATH", "$." + roomName + "." + triggeringItem.state.toString + ".color" , json)

    var strBrightness = transform("JSONPATH", "$." + roomName + "." + triggeringItem.state.toString + ".brightness" , json)


    // Catching Errors
    if(group === null) {
	logError("admin", "Cannot find Item " + "group_"+roomName +"_lights")
	return;
    }

    // Switching all lights off manually, since there is no likewise defined mood
    if (triggeringItem.state == 0) {
	group.members.forEach[ i | i.sendCommand(OFF) ]
    }

    // Lampen werden manuell auf 100 geschaltet, wenn Stellung AN gewählt wurde.
    // Die Lichtfarbe wird automatisch aus der vorher definierten moods.map gezogen, damit die Lampen alle diesselbe Color haben.
    else if (triggeringItem.state ==1) {
	logInfo("Notification", "group to set ON: " + group.name)
	group.members.forEach[ i | i.sendCommand(100) ]
	groupCol.members.forEach[ i | i.sendCommand("0,0," + strColor)]
	}

	else{
	    // definition must take place after state On or Off are handled since these are not discrete groups.
	    val scenegroupcol = ScriptServiceUtil.getItemRegistry.getItem( "group_"+roomName +"_color_" +transform("JSONPATH", "$." + roomName + "." + triggeringItem.state.toString  + ".mood", json)) as GroupItem 
	    val scenegroup = ScriptServiceUtil.getItemRegistry.getItem( "group_"+roomName +"_lights_" +transform("JSONPATH", "$." + roomName + "." + triggeringItem.state.toString + ".mood", json)) as GroupItem

	    if(scenegroup === null) {
		logError("admin", "Cannot find Item " + "group_"+roomName +"_lights_" +transform("MAP", roomName +".map", "brightness"))
		return;
	    }

	    // All lights within the set group are set to the brightness defined in the json string. All others are switched off	
	    if (switchNight.state.toString == "ON" && switchLightAuto .state.toString == "ON") { strBrightness = dimmerBrightness.state.toString }
	    group.members.forEach[ i |
		if (i.getGroupNames.contains(scenegroup.name)){
			if (i.name.contains("Power")){
				i.sendCommand("ON")
			} else{
				i.sendCommand(strBrightness)
			}
		}
		else{
		    i.sendCommand(OFF)
		}
	    ]
		    
	    // Für alle Lampen, die in der Gruppe der entsprechenden Szene enthalten sind, wird die Farbtemperatur abhängig von den Vorgabewerten in moods.map gesetzt.	
	    if (strColor !== null) {
		groupCol.members.forEach[ i |
		    if (i.getGroupNames.contains(scenegroupcol.name)){
			i.sendCommand("0,0," + strColor)
		    }
		    else{
			i.sendCommand(OFF)
		    }
		]
	    }

	    // Aktuelle Werte an Dimmer senden, damit die Werte auf der Weboberfläche über einstimmen
	    dimmerBrightness.sendCommand(strBrightness)
	    dimmerColor.sendCommand(strColor)
	}
end



rule "Adjust Brightness"
when 
    Item dimmerBrightness changed
then
    /* 
	Wenn der Int dimmerBrightness entweder durch den Schieberegler oder durch andere Regeln geändert wird, wird für alle Lampen, deren Brightness nicht 0 ist, dimmerHelligkeit als neuer Wert festgelegt.
    */

    if (dimmerBrightness.state == 0){
	    group.members.forEach[ i | i.sendCommand(OFF)]
    } else{
	    group_lr_lights.members.forEach[ i | 
		if (i.state > 0){
		    i.sendCommand(dimmerBrightness.state.toString)
		    Thread::sleep(200) // Lights won't change if there is no sleep.
		}
	    ]
    }
end

rule "Colorn anpassen - global"
when
    Item dimmerColor changed
then
    group_lr_lights.members.forEach[ i |
	if (i.state  > 0){
	    val currentItemi = ScriptServiceUtil.getItemRegistry.getItem(i.name.replace("dim", "col")) 
	    currentItemi.sendCommand(dimmerColor.state.toString)
	}
    ]
end

// AUTOMATISIERUNG

rule "Automatische Abdunklung"
when
	// Jeden Tag zwischen 19 und 0 Uhr, alle 5 Minuten.
	Time cron "0 0/5 19-0 * * ?" 
then
	// Wenn es Nacht ist und die Lichtautomatik eingeschaltet wurde, wird die Brightness gemäß Timer alle 15 Minuten um 10% verringert. 
	// Sobald die Brightness zu gering ist, wird sie nicht weiter verringert. Wenn nicht Nacht ist, werden die Lampen ausgeschaltet.

	if (switchNight.state.toString == "ON") {
		var intBrightness_transfer = Integer::parseInt(dimmerBrightness.state.toString) 
		if (intBrightness_transfer >= 20) {
			intBrightness_transfer = intBrightness_transfer - 2 
			if (switchLightAuto.state.toString == "ON"){dimmerBrightness.postUpdate(intBrightness_transfer.toString)}
			logInfo("Automatik", "Brightness verringert")
		}
		else{
			switchLightAuto.sendCommand(OFF)
		}			
	}
end

/*	
	Wenn der Switch, der Tag oder Nacht darstellt, geändert wird, wird automatisch eine Szene aktiviert bzw. deaktiviert.
	Die Szene wird im Dashbord selbst gewählt, Standardwert bei Systemstart (nach Ausfällen) wird auf Gruppe "Morgen" gesetzt. 
	Morgens wird an Wochentagen immer das Licht angemacht, außer die Sonne ist bereits aufgegangen. 
	Ansonsten wird nach Sonnenaufgang die Beleuchtung ausgeschaltet.
*/

rule "morgens aus/abends an"
when
	Item switchNight changed
then
	var intCount	
	if (switchNight.state.toString == "ON") {

	if (atLeastOneLight.state.toString == "OFF") { 
		    lr_scene.sendCommand(3)// nmbNightAuto.state.toString)
		    dimmerBrightness.sendCommand(100)
		    // logInfo("Nacht", "Es ist Abend, ich schalte an: " + transform("JSONPATH", "$.lr." + nmbNightAuto.state.toString  + ".mood", json))
	}
	    switchLightAuto.sendCommand(ON)
	}
	else {
			lr_scene.sendCommand(0)
			switchLightAuto.sendCommand(OFF)
	}
end
	
rule "morgens an"
when
	Time cron "0 15 6  ? * MON-FRI" or
	Time cron "0 0 8 ? * SAT-SUN"
then
	 // if (nmbDayAuto.state.toString === null) { nmbDayAuto.sendCommand(3)}
	logInfo("Morgen", "Es ist morgen, ich schalte an...")
	if (switchNight.state.toString=="ON") {
		lr_scene.sendCommand(3) // nmbDayAuto.state.toString)
		logInfo("Morgen", "... Stimmung morgen ist aktiviert! :)")
	} 
end

// TAGESZEITREGELN

/*
	Damit der folgende Code funktionieren kann *muss* das Astrobinding im UI erstellt sein - anderenfalls funktioniert der Versatz nicht.
	Bindings ohne Offset könnten auch in einer Thingdatei konfiguriert sein.
*/

rule "Tageszeit Nacht"
when 
	Channel 'astro:sun:local:set#event' triggered START
then
	switchNight.sendCommand(ON)
	logInfo("Tag/Nacht", "Die Sonne geht UNTER, es ist NACHT.")
end


rule "Tageszeit Tag"
when
	Channel 'astro:sun:local:rise#event' triggered START
then 
	switchNight.sendCommand(OFF)
	logInfo("Tag/Nacht", "Die Sonne geht AUF, es ist TAG.")
end

rule "Nachtabschaltung"
when
	Time cron "0 30 23 ? * SUN-THU" or
	Time cron "0 30 23 ? * FRI-SAT"
then
	group_lr_lights.sendCommand(OFF)
end


rule "Handy Detection"
when
	Item handypre changed 
then
	var intBrightHandy = Integer::parseInt("0")
	var block = False
	if (block && handypre.state.toString  == "ON" && switchNight.state.toString == "ON"){
		group_lr_lights.members.forEach[ e  |
			if (e.state > 0) {
				intBrightHandy = intBrightHandy + Integer::parseInt(e.state.toString)
				logInfo("Info", e.state + "")
			}
		]
		if (intBrightHandy > 0 ) {
		lr_scene.sendCommand("3")
		handypre.sendComand("OFF")
	}
}
end

rule "Check if there is at least one light switched on"
when
    Time cron "0/30 * * ? * *"
then
    var intSumBrightness = 0
    group_lr_lights.members.forEach[ j | 
	//logInfo("Schalter", "State: " + j.state)
	var intItemBrightness = 0
	if (j.state.toString.contains("O")) {
	    if (j.state.toString.contains("F")) { intItemBrightness = 0 } 
	    else { intItemBrightness = 1 }
	} else { intItemBrightness = Integer::parseInt(j.state.toString) }

	intSumBrightness = intSumBrightness + intItemBrightness
    ]
    if (intSumBrightness > 0){ atLeastOneLight.sendCommand("ON") }
    else { atLeastOneLight.sendCommand("OFF") }
end
